<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态圆形</title>
    <style>
        body, html { height: 100%; margin: 0; overflow: hidden; }
        .circle {
            position: absolute;
            overflow: visible; /* 确保SVG不被切割 */
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const container = document.getElementById('container');
            let baseYear = 2003; // 基础年份
            let initialCircles = 0; // 初始圆的数量

            // 生成随机颜色
            const getRandomColor = () => {
                const opacity = Math.random() * 0.5 + 0.5; // 透明度从0.5到1.0
                const red = Math.floor(Math.random() * 30) + 125; // Red from 125 to 155
                const green = red - 40; // Green always less than red
                const blue = red - 90; // Blue always less than green
                return `rgba(${red}, ${green}, ${blue}, ${opacity})`;
            };

            // 创建一个包含扭曲线段的圆形
            const createCircle = () => {
                const size = Math.random() * 80 + 40; // 随机大小，40px到120px
                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg.setAttribute("width", size);
                svg.setAttribute("height", size);

                // 添加扭曲的线段
                const segments = 3 + Math.floor(Math.random() * 5); // 3到7个扭曲的线段
                for (let i = 0; i < segments; i++) {
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    const d = generatePathData(size / 2, size / 2, size / 2 - 1, i, segments);
                    path.setAttribute("d", d);
                    path.setAttribute("stroke", getRandomColor());
                    path.setAttribute("stroke-width", "2");
                    path.setAttribute("fill", "none");
                    svg.appendChild(path);
                }

                const wrapper = document.createElement('div');
                wrapper.className = 'circle';
                wrapper.style.left = `${Math.random() * (window.innerWidth - size)}px`;
                wrapper.style.top = `${Math.random() * (window.innerHeight - size)}px`;
                wrapper.appendChild(svg);
                container.appendChild(wrapper);
                moveCircle(wrapper);
                return wrapper;
            };

            // 生成路径数据，模拟扭曲和断开
            const generatePathData = (cx, cy, r, index, total) => {
                const angle = 360 / total;
                const startAngle = angle * index;
                const endAngle = startAngle + angle;
                const largeArc = Math.random() > 0.5 ? 1 : 0; // 随机选择大圆弧或小圆弧
                const sweep = 1; // 总是顺时针
                const startX = cx + r * Math.cos(startAngle * Math.PI / 180);
                const startY = cy + r * Math.sin(startAngle * Math.PI / 180);
                const endX = cx + r * Math.cos(endAngle * Math.PI / 180);
                const endY = cy + r * Math.sin(endAngle * Math.PI / 180);
                // 使用贝塞尔曲线平滑连接点
                return `M${startX} ${startY} Q ${cx} ${cy}, ${endX} ${endY}`;
            };

            // 缓慢移动圆形
            const moveCircle = (wrapper) => {
                let dx = (Math.random() * 0.5 - 0.25); // 水平移动速度
                let dy = (Math.random() * 0.5 - 0.25); // 垂直移动速度
                const move = () => {
                    let rect = wrapper.getBoundingClientRect();
                    let newX = rect.left + dx;
                    let newY = rect.top + dy;

                    if (newX < 0 || newX + rect.width > window.innerWidth) {
                        dx = -dx;
                        newX = rect.left + dx;
                    }
                    if (newY < 0 || newY + rect.height > window.innerHeight) {
                        dy = -dy;
                        newY = rect.top + dy;
                    }

                    wrapper.style.left = `${newX}px`;
                    wrapper.style.top = `${newY}px`;

                    requestAnimationFrame(move);
                };
                requestAnimationFrame(move);
            };

            // 初始化所有圆
            const initCircles = () => {
                const count = getCircleCount();
                for (let i = 0; i < count; i++) {
                    createCircle(); // 初始随机大小圆
                }
            };

            const getCircleCount = () => initialCircles + new Date().getFullYear() - baseYear;

            initCircles();
        });
    </script>
</body>
</html>
